{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LEAP (Learning-Enabled Abstraction for Planning) # CogMan: cognitive manager that employs strategists and commonsense knowledge to solve big, complex problems Pre-problem Strategists: a sequence of (learned) components that map a big problem into a sequence of smaller problems by making hierarchical or temporal abstractions HPN: (v1) relax preconditions with fixed hierarchy (v2) with learned importance score PLOI: (v1) find minimum set of objects at the beginning of solving the problem (v2) change the set dynamically C2S2 (context-conditioned subgoal suggestor): (v1) with 3-gram models (v2) with language models Post-problem Strategists: a sequence of components that improve a plan VNS: to change the order of operators, e.g. open the fridge only once to get both the meat and cheese Usage # Run run.py with the domain and problem pddl files, along with the sequence of strategists to use. The code searches for the pddl files in all sub-directories of domains/ . ## the general template python run.py domain.pddl problem.pddl -o 'large_domain_objects.pddl' -p [fd/pp] -s 'hpn,c2s2,pre-strategists separated by comma' -v [0/1/2] -e 'experiment_output_directory' ## this should work and generate an output dir with plan and log in experiments/dev python run.py kitchen_1.pddl omelette_5.pddl -o obj_3.pddl -v 2 -e 'experiments/dev' ## this needs to run successfully for every new version of the code and domain files ./tests.sh Note that kitchen_3.pddl and obj_eggs.pddl are currently being actively developed for a larger kitchen domain. Helper functions: ## post_experiments.py prints a table of experimental stats in directory python generators/post_experiments.py experiments/kitchen_operators ## init_objects.py converts doc/objects.md file to PDDL tuples of types and objects python generators/init_objects.py Available Planners # df : FastDownward with lama-first. Better than PyperPlan in that it can take ADL expressions for using forall/exists/when. It also supports action costs and axioms (see downward/driver/aliases.py and Doc/Evaluator ). But it doesn't support PDDL 2+ and 3+ features, like fluents, numerical planning, temporal planning, soft goals & preferences. ALIASES[\"lama-first\"] = [ \"--evaluator\", \"hlm=lmcount(lm_factory=lm_reasonable_orders_hps(lm_rhw()),transform=adapt_costs(one),pref=false)\", \"--evaluator\", \"hff=ff(transform=adapt_costs(one))\", \"--search\", \"\"\"lazy_greedy([hff,hlm],preferred=[hff,hlm], cost_type=one,reopen_closed=false)\"\"\"] pp : PyperPlan with Greedy Best First Search and FF heuristic Available Strategists # hpn , ploi or c2s2 : output the original domain and problem pddl Domains # You may find more classic IPC domains in FF Domain Collection and IPC2018 domains . Kitchen domain # (exist-egg-in-hole ?x - env) (exist-poached-egg ?x - env) (exist-baked-egg ?x - env) (exist-boiled-egg ?x - env) (exist-deviled-egg ?x - env) (exist-cloud-egg ?x - env) (exist-quiche ?x - env) Experiments # Write your test script like test_goals.sh with all test cases. You can also add the following lines to tests.sh : chmod +x test_something.sh ./test_something.sh","title":"LEAP Architecture"},{"location":"#leap-learning-enabled-abstraction-for-planning","text":"CogMan: cognitive manager that employs strategists and commonsense knowledge to solve big, complex problems Pre-problem Strategists: a sequence of (learned) components that map a big problem into a sequence of smaller problems by making hierarchical or temporal abstractions HPN: (v1) relax preconditions with fixed hierarchy (v2) with learned importance score PLOI: (v1) find minimum set of objects at the beginning of solving the problem (v2) change the set dynamically C2S2 (context-conditioned subgoal suggestor): (v1) with 3-gram models (v2) with language models Post-problem Strategists: a sequence of components that improve a plan VNS: to change the order of operators, e.g. open the fridge only once to get both the meat and cheese","title":"LEAP (Learning-Enabled Abstraction for Planning)"},{"location":"#usage","text":"Run run.py with the domain and problem pddl files, along with the sequence of strategists to use. The code searches for the pddl files in all sub-directories of domains/ . ## the general template python run.py domain.pddl problem.pddl -o 'large_domain_objects.pddl' -p [fd/pp] -s 'hpn,c2s2,pre-strategists separated by comma' -v [0/1/2] -e 'experiment_output_directory' ## this should work and generate an output dir with plan and log in experiments/dev python run.py kitchen_1.pddl omelette_5.pddl -o obj_3.pddl -v 2 -e 'experiments/dev' ## this needs to run successfully for every new version of the code and domain files ./tests.sh Note that kitchen_3.pddl and obj_eggs.pddl are currently being actively developed for a larger kitchen domain. Helper functions: ## post_experiments.py prints a table of experimental stats in directory python generators/post_experiments.py experiments/kitchen_operators ## init_objects.py converts doc/objects.md file to PDDL tuples of types and objects python generators/init_objects.py","title":"Usage"},{"location":"#available-planners","text":"df : FastDownward with lama-first. Better than PyperPlan in that it can take ADL expressions for using forall/exists/when. It also supports action costs and axioms (see downward/driver/aliases.py and Doc/Evaluator ). But it doesn't support PDDL 2+ and 3+ features, like fluents, numerical planning, temporal planning, soft goals & preferences. ALIASES[\"lama-first\"] = [ \"--evaluator\", \"hlm=lmcount(lm_factory=lm_reasonable_orders_hps(lm_rhw()),transform=adapt_costs(one),pref=false)\", \"--evaluator\", \"hff=ff(transform=adapt_costs(one))\", \"--search\", \"\"\"lazy_greedy([hff,hlm],preferred=[hff,hlm], cost_type=one,reopen_closed=false)\"\"\"] pp : PyperPlan with Greedy Best First Search and FF heuristic","title":"Available Planners"},{"location":"#available-strategists","text":"hpn , ploi or c2s2 : output the original domain and problem pddl","title":"Available Strategists"},{"location":"#domains","text":"You may find more classic IPC domains in FF Domain Collection and IPC2018 domains .","title":"Domains"},{"location":"#kitchen-domain","text":"(exist-egg-in-hole ?x - env) (exist-poached-egg ?x - env) (exist-baked-egg ?x - env) (exist-boiled-egg ?x - env) (exist-deviled-egg ?x - env) (exist-cloud-egg ?x - env) (exist-quiche ?x - env)","title":"Kitchen domain"},{"location":"#experiments","text":"Write your test script like test_goals.sh with all test cases. You can also add the following lines to tests.sh : chmod +x test_something.sh ./test_something.sh","title":"Experiments"},{"location":"domain-kitchen/","text":"Kitchen Domain #","title":"Kitchen"},{"location":"domain-kitchen/#kitchen-domain","text":"","title":"Kitchen Domain"},{"location":"exp-egg-recipes/","text":"Different recipes -> Search time corresponds to # of axioms and depth of search, instead of # of operators or length of plan # test_egg_recipes.sh tests the search complexity of 10 different egg-related recipes, with the same kitchen_3.pddl and obj_eggs.pddl , i.e. with all definitions and objects for egg recipes: scrambled_eggs.pddl specifies beaten, scrambled eggs omelette.pddl specifies beaten, folded eggs with veggies sunny_side_up.pddl specifies fried, steamed eggs on frypan egg_in_hole.pddl specifies fried egg in the hole of a bread poached_egg.pddl specifies boiled egg with vinegar t problem_name var op axiom plan parse search state ------ --------------------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 085358 kitchen_egg_4-scrambled_eggs-obj_egg_4.pddl-scrambled_eggs.pddl 312 6677 161 43 9.846 0.120834 749 085408 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.03 0.119653 711 085419 kitchen_egg_4-sunny_side_up-obj_egg_4.pddl-sunny_side_up.pddl 142 4560 125 28 10.377 0.272117 2501 085432 kitchen_egg_4-egg_in_hole-obj_egg_4.pddl-crack 202 3234 172 50 10.129 2.14165 24498 085447 kitchen_3-poached_egg-obj_eggs.pddl-poached_egg.pddl 368 4944 137 25 14.394 0.0189829 144 Comparing the goal definition and search tree of Omelette (0.12s), Sunny Side Up (0.27s), and Egg in a Hole (2.14s) ( :derived ( exist-omelette ?env - env ) ( exists ( ?egg1 - egg ?veggies1 - ingredient ?plate1 - plate ) ( and ( inside ?plate1 ?egg1 ) ( beaten ?egg1 ) ( fried ?egg1 ) ( folded ?egg1 ) ( is-buttery ?egg1 ) ( fried ?veggies1 ) ( sauteed ?veggies1 ) ( has-seasoning ?egg1 nutmilk cup two ) ( has-seasoning ?egg1 chives tablespoon2 two ) ( seasoning-mixed ?egg1 chives ) ( has-seasoning ?egg1 salt gram two ) ( seasoning-mixed ?egg1 salt ) ( has-seasoning ?egg1 pepper gram two ) ( seasoning-mixed ?egg1 pepper ) ) ) ) ( :derived ( exist-sunny-side-up ?env - env ) ( exists ( ?egg1 - egg ?plate1 - plate ) ( and ( inside ?plate1 ?egg1 ) ( fried ?egg1 ) ;( is-buttery ?egg1 ) ; SHOW: weirdly cannot use butter here ( steamed ?egg1 ) ( has-seasoning ?egg1 salt gram one ) ( has-seasoning ?egg1 pepper gram one ) ) ) ) ( :derived ( exist-egg-in-hole ?env - env ) ( exists ( ?egg1 - egg ?bread1 - bread ?plate1 - plate ) ( and ( inside ?plate1 ?bread1 ) ( has-hole ?bread1 circle ) ( in-hole ?egg1 ?bread1 ) ( fried ?bread1 ) ; ( fried ?egg1 ) ; cannot achieve this because egg1 not in frypan but in the hole of bread which is on frypan ( is-buttery ?bread1 ) ( has-seasoning ?egg1 salt gram one ) ( has-seasoning ?egg1 pepper gram one ) ) ) ) The plan of making an omelette (length = 52): open fridge (0) getout egg1 fridge robot (0) close fridge (0) crack-egg egg1 bigbowl1 robot (0) open fridge (0) getout milkbottle1 fridge robot (0) getout butter fridge robot (0) getout veggies1 fridge robot (0) close fridge (0) add-ingredient butter smallbowl1 robot (0) add-ingredient veggies1 smallbowl1 robot (0) pour bigbowl1 nutmilk milkbottle1 cup robot (0) pour bigbowl1 nutmilk milkbottle1 cup robot (0) putdown fork1 burner robot (0) pickup bigbowl1 kitchentop robot (0) putdown milkbottle1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 cup robot (0) sprinkle egg1 salt salter1 gram robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown salter1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 cup robot (0) sprinkle egg1 pepper shaker1 gram robot (0) sprinkle egg1 pepper shaker1 gram robot (0) putdown shaker1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer butter smallbowl1 frypan1 robot (0) transfer veggies1 smallbowl1 frypan1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup tablespoon2 kitchentop robot (0) season egg1 chives container1 tablespoon2 robot (0) season egg1 chives container1 tablespoon2 robot (0) putdown tablespoon2 burner robot (0) pickup fork1 kitchentop robot (0) putdown fork1 burner robot (0) pickup fork1 burner robot (0) mix egg1 fork1 bigbowl1 robot (10) switchon burner frypan1 (0) fry veggies1 frypan1 burner butter (0) transfer egg1 bigbowl1 frypan1 robot (0) fry egg1 frypan1 burner butter (0) switchoff burner frypan1 (0) putdown fork1 burner robot (0) pickup frypan1 burner robot (0) putdown smallbowl1 burner robot (0) pickup spatula1 kitchentop robot (0) fold egg1 frypan1 spatula1 robot (0) transfer egg1 frypan1 plate1 robot (0) The plan of making an sunny-side-up (length = 28): open fridge (0) getout egg1 fridge robot (0) close fridge (0) crack-egg egg1 smallbowl1 robot (0) open dcup2 (0) getout oilbottle1 dcup2 robot (0) close dcup2 (0) transfer oliveoil oilbottle1 frypan1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) getout pancover1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer egg1 smallbowl1 frypan1 robot (0) switchon burner frypan1 (0) fry egg1 frypan1 burner oliveoil (0) puton pancover1 frypan1 robot (0) steam egg1 frypan1 burner (0) switchoff burner frypan1 (0) pickup frypan1 burner robot (0) transfer egg1 frypan1 plate1 robot (0) putdown fork1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown smallbowl1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 gram robot (0) The plan of making an egg-in-hole (length = 50): putdown fork1 burner robot (0) pickup holecutter1 kitchentop robot (0) make-hole bread1 holecutter1 circle robot (1) open fridge (0) getout butter fridge robot (0) getout egg1 fridge robot (0) close fridge (0) crack-egg-3 egg1 bread1 robot (1) add-ingredient butter smallbowl1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown salter1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 gram robot (0) putdown shaker1 burner robot (0) pickup bread1 kitchentop robot (0) add-ingredient bread1 smallbowl1 robot (0) putdown holecutter1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer bread1 smallbowl1 plate1 robot (0) putdown smallbowl1 burner robot (0) pickup plate1 kitchentop robot (0) open dcup2 (0) getout oilbottle1 dcup2 robot (0) close dcup2 (0) transfer oliveoil oilbottle1 frypan1 robot (0) putdown plate1 burner robot (0) pickup smallbowl1 burner robot (0) transfer butter smallbowl1 frypan1 robot (0) putdown smallbowl1 burner robot (0) pickup plate1 burner robot (0) transfer bread1 plate1 frypan1 robot (0) putdown plate1 burner robot (0) pickup frypan1 burner robot (0) transfer bread1 frypan1 plate1 robot (0) putdown oilbottle1 burner robot (0) pickup plate1 burner robot (0) putdown frypan1 burner robot (0) pickup fork1 burner robot (0) switchon burner frypan1 (0) transfer bread1 plate1 frypan1 robot (0) fry bread1 frypan1 burner butter (0) switchoff burner frypan1 (0) putdown fork1 burner robot (0) pickup frypan1 burner robot (0) transfer bread1 frypan1 plate1 robot (0)","title":"All Egg Recipes"},{"location":"exp-egg-recipes/#different-recipes-search-time-corresponds-to-of-axioms-and-depth-of-search-instead-of-of-operators-or-length-of-plan","text":"test_egg_recipes.sh tests the search complexity of 10 different egg-related recipes, with the same kitchen_3.pddl and obj_eggs.pddl , i.e. with all definitions and objects for egg recipes: scrambled_eggs.pddl specifies beaten, scrambled eggs omelette.pddl specifies beaten, folded eggs with veggies sunny_side_up.pddl specifies fried, steamed eggs on frypan egg_in_hole.pddl specifies fried egg in the hole of a bread poached_egg.pddl specifies boiled egg with vinegar t problem_name var op axiom plan parse search state ------ --------------------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 085358 kitchen_egg_4-scrambled_eggs-obj_egg_4.pddl-scrambled_eggs.pddl 312 6677 161 43 9.846 0.120834 749 085408 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.03 0.119653 711 085419 kitchen_egg_4-sunny_side_up-obj_egg_4.pddl-sunny_side_up.pddl 142 4560 125 28 10.377 0.272117 2501 085432 kitchen_egg_4-egg_in_hole-obj_egg_4.pddl-crack 202 3234 172 50 10.129 2.14165 24498 085447 kitchen_3-poached_egg-obj_eggs.pddl-poached_egg.pddl 368 4944 137 25 14.394 0.0189829 144 Comparing the goal definition and search tree of Omelette (0.12s), Sunny Side Up (0.27s), and Egg in a Hole (2.14s) ( :derived ( exist-omelette ?env - env ) ( exists ( ?egg1 - egg ?veggies1 - ingredient ?plate1 - plate ) ( and ( inside ?plate1 ?egg1 ) ( beaten ?egg1 ) ( fried ?egg1 ) ( folded ?egg1 ) ( is-buttery ?egg1 ) ( fried ?veggies1 ) ( sauteed ?veggies1 ) ( has-seasoning ?egg1 nutmilk cup two ) ( has-seasoning ?egg1 chives tablespoon2 two ) ( seasoning-mixed ?egg1 chives ) ( has-seasoning ?egg1 salt gram two ) ( seasoning-mixed ?egg1 salt ) ( has-seasoning ?egg1 pepper gram two ) ( seasoning-mixed ?egg1 pepper ) ) ) ) ( :derived ( exist-sunny-side-up ?env - env ) ( exists ( ?egg1 - egg ?plate1 - plate ) ( and ( inside ?plate1 ?egg1 ) ( fried ?egg1 ) ;( is-buttery ?egg1 ) ; SHOW: weirdly cannot use butter here ( steamed ?egg1 ) ( has-seasoning ?egg1 salt gram one ) ( has-seasoning ?egg1 pepper gram one ) ) ) ) ( :derived ( exist-egg-in-hole ?env - env ) ( exists ( ?egg1 - egg ?bread1 - bread ?plate1 - plate ) ( and ( inside ?plate1 ?bread1 ) ( has-hole ?bread1 circle ) ( in-hole ?egg1 ?bread1 ) ( fried ?bread1 ) ; ( fried ?egg1 ) ; cannot achieve this because egg1 not in frypan but in the hole of bread which is on frypan ( is-buttery ?bread1 ) ( has-seasoning ?egg1 salt gram one ) ( has-seasoning ?egg1 pepper gram one ) ) ) ) The plan of making an omelette (length = 52): open fridge (0) getout egg1 fridge robot (0) close fridge (0) crack-egg egg1 bigbowl1 robot (0) open fridge (0) getout milkbottle1 fridge robot (0) getout butter fridge robot (0) getout veggies1 fridge robot (0) close fridge (0) add-ingredient butter smallbowl1 robot (0) add-ingredient veggies1 smallbowl1 robot (0) pour bigbowl1 nutmilk milkbottle1 cup robot (0) pour bigbowl1 nutmilk milkbottle1 cup robot (0) putdown fork1 burner robot (0) pickup bigbowl1 kitchentop robot (0) putdown milkbottle1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 cup robot (0) sprinkle egg1 salt salter1 gram robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown salter1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 cup robot (0) sprinkle egg1 pepper shaker1 gram robot (0) sprinkle egg1 pepper shaker1 gram robot (0) putdown shaker1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer butter smallbowl1 frypan1 robot (0) transfer veggies1 smallbowl1 frypan1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup tablespoon2 kitchentop robot (0) season egg1 chives container1 tablespoon2 robot (0) season egg1 chives container1 tablespoon2 robot (0) putdown tablespoon2 burner robot (0) pickup fork1 kitchentop robot (0) putdown fork1 burner robot (0) pickup fork1 burner robot (0) mix egg1 fork1 bigbowl1 robot (10) switchon burner frypan1 (0) fry veggies1 frypan1 burner butter (0) transfer egg1 bigbowl1 frypan1 robot (0) fry egg1 frypan1 burner butter (0) switchoff burner frypan1 (0) putdown fork1 burner robot (0) pickup frypan1 burner robot (0) putdown smallbowl1 burner robot (0) pickup spatula1 kitchentop robot (0) fold egg1 frypan1 spatula1 robot (0) transfer egg1 frypan1 plate1 robot (0) The plan of making an sunny-side-up (length = 28): open fridge (0) getout egg1 fridge robot (0) close fridge (0) crack-egg egg1 smallbowl1 robot (0) open dcup2 (0) getout oilbottle1 dcup2 robot (0) close dcup2 (0) transfer oliveoil oilbottle1 frypan1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) getout pancover1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer egg1 smallbowl1 frypan1 robot (0) switchon burner frypan1 (0) fry egg1 frypan1 burner oliveoil (0) puton pancover1 frypan1 robot (0) steam egg1 frypan1 burner (0) switchoff burner frypan1 (0) pickup frypan1 burner robot (0) transfer egg1 frypan1 plate1 robot (0) putdown fork1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown smallbowl1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 gram robot (0) The plan of making an egg-in-hole (length = 50): putdown fork1 burner robot (0) pickup holecutter1 kitchentop robot (0) make-hole bread1 holecutter1 circle robot (1) open fridge (0) getout butter fridge robot (0) getout egg1 fridge robot (0) close fridge (0) crack-egg-3 egg1 bread1 robot (1) add-ingredient butter smallbowl1 robot (0) open dcup1 (0) getout frypan1 dcup1 robot (0) close dcup1 (0) putdown frypan1 burner robot (0) pickup salter1 kitchentop robot (0) sprinkle egg1 salt salter1 gram robot (0) putdown salter1 burner robot (0) pickup shaker1 kitchentop robot (0) sprinkle egg1 pepper shaker1 gram robot (0) putdown shaker1 burner robot (0) pickup bread1 kitchentop robot (0) add-ingredient bread1 smallbowl1 robot (0) putdown holecutter1 burner robot (0) pickup smallbowl1 kitchentop robot (0) transfer bread1 smallbowl1 plate1 robot (0) putdown smallbowl1 burner robot (0) pickup plate1 kitchentop robot (0) open dcup2 (0) getout oilbottle1 dcup2 robot (0) close dcup2 (0) transfer oliveoil oilbottle1 frypan1 robot (0) putdown plate1 burner robot (0) pickup smallbowl1 burner robot (0) transfer butter smallbowl1 frypan1 robot (0) putdown smallbowl1 burner robot (0) pickup plate1 burner robot (0) transfer bread1 plate1 frypan1 robot (0) putdown plate1 burner robot (0) pickup frypan1 burner robot (0) transfer bread1 frypan1 plate1 robot (0) putdown oilbottle1 burner robot (0) pickup plate1 burner robot (0) putdown frypan1 burner robot (0) pickup fork1 burner robot (0) switchon burner frypan1 (0) transfer bread1 plate1 frypan1 robot (0) fry bread1 frypan1 burner butter (0) switchoff burner frypan1 (0) putdown fork1 burner robot (0) pickup frypan1 burner robot (0) transfer bread1 frypan1 plate1 robot (0)","title":"Different recipes -&gt; Search time corresponds to # of axioms and depth of search, instead of # of operators or length of plan"},{"location":"exp-goals/","text":"More goal predicates -> Search time increases more than linearly # test_goals.sh tests the effect of increasing the number of goal predicates on search complexity, with the same kitchen_1 .pddl and obj_1 .pddl, i.e. minimum operators & objects: omelette_1.pddl has only eggs omelette_2.pddl adds veggies omelette_3.pddl adds salt and pepper omelette_4.pddl adds nutmilk and chives omelette_5.pddl contains all positive goal predicates without any use of axioms omelette_6.pddl contains one negative goal predicate omelette_7.pddl contains two negative goal predicates t problem_name var op axiom plan parse search state ------ --------------- ----- ---- ------- ------ ------- ---------- ------- 085529 omelette_1.pddl 39 700 8 16 0.632 0.0016525 29 085530 omelette_2.pddl 43 702 11 20 0.618 0.00334604 40 085531 omelette_3.pddl 44 703 11 24 0.666 0.00299829 48 085532 omelette_4.pddl 58 843 11 50 0.675 0.0119693 246 085533 omelette_5.pddl 66 1004 11 48 0.598 0.0155517 243 085534 omelette_6.pddl 68 1004 13 64 0.579 0.0691776 1134 085535 omelette_7.pddl 68 1004 13 64 0.592 0.0721683 1134","title":"Num of Goal Predicates"},{"location":"exp-goals/#more-goal-predicates-search-time-increases-more-than-linearly","text":"test_goals.sh tests the effect of increasing the number of goal predicates on search complexity, with the same kitchen_1 .pddl and obj_1 .pddl, i.e. minimum operators & objects: omelette_1.pddl has only eggs omelette_2.pddl adds veggies omelette_3.pddl adds salt and pepper omelette_4.pddl adds nutmilk and chives omelette_5.pddl contains all positive goal predicates without any use of axioms omelette_6.pddl contains one negative goal predicate omelette_7.pddl contains two negative goal predicates t problem_name var op axiom plan parse search state ------ --------------- ----- ---- ------- ------ ------- ---------- ------- 085529 omelette_1.pddl 39 700 8 16 0.632 0.0016525 29 085530 omelette_2.pddl 43 702 11 20 0.618 0.00334604 40 085531 omelette_3.pddl 44 703 11 24 0.666 0.00299829 48 085532 omelette_4.pddl 58 843 11 50 0.675 0.0119693 246 085533 omelette_5.pddl 66 1004 11 48 0.598 0.0155517 243 085534 omelette_6.pddl 68 1004 13 64 0.579 0.0691776 1134 085535 omelette_7.pddl 68 1004 13 64 0.592 0.0721683 1134","title":"More goal predicates -&gt; Search time increases more than linearly"},{"location":"exp-objects/","text":"More objects -> Search time increases linearly with alternative utensils # test_objects.sh tests the effect of increasing the number of objects on search complexity by adding objects to obj_0.pddl , with the same set of operators in kitchen_1.pddl and the same goal definition in omelette_5.pddl , i.e. a full omelette: obj_0.pddl contains the bare minimum set of objects --> [Note 2] obj_1.pddl adds 3 extranuous objects (i.e. pot/pan, bread/veggies, oliveoil/butter) obj_2.pddl adds 3 alternative objects (i.e. knife/fork, bigbowl/smallbowl, saltedbutter/butter) obj_3.pddl contains 10 eggs and 10 veggies (the goal mentions egg1 and veggie1) --> [Note 1] obj_4.pddl contains multiples (2) of every utensil (11) --> [Note 3] obj_5.pddl contains multiples (10) of every utensil (11) --> [Conclusion 1] obj_eggs_0.pddl contains the bare minimum set of objects for making 10 egg recipes t problem_name var op axiom plan parse search state ------ -------------- ----- ----- ------- ------ ------- --------- ------- 142459 obj_0.pddl 56 932 11 48 0.483 0.0119011 * 177 142501 obj_1.pddl 61 1522 13 55 1.211 0.0194257 348 142502 obj_2.pddl 60 1280 13 54 0.898 0.0389651 * 580 142505 obj_3.pddl 92 2930 46 48 2.721 0.0209925 181 142507 obj_4.pddl 119 2849 11 63 1.701 0.0684566 * 678 142546 obj_5.pddl 429 56083 11 53 37.081 0.596486 * 907 Conclusion 1: Search time increases linearly with alternative utensils # Looking at line 1, line 3 (added 3 alternative utensil), line 5 (duplicated number of utensils by 2), and line 6 (duplicated number of utensils by 10), we notice that search time increases almost linearly number of operators increases more than linearly number of axioms doesn't change plan lengths are different (strange) Note 1: Use Axioms to define recipe # Note that 10 eggs and 10 veggies only has a small effect when the goal mentions only the existance of egg and veggies, as opposed to mentioning egg1 and veggie1 : obj_0.pddl + omelette_5.pddl ( obj_0.pddl contains the bare minimum set of objects) obj_3.pddl + omelette_5.pddl ( obj_3.pddl contains 10 eggs and 10 veggies) obj_3.pddl + omelette_5b.pddl , which contains goal (exist-omelette kitchen) t problem_name var op axiom plan parse search state ------ ----------------------- ----- ---- ------- ------ ------- --------- ------- 144457 obj_0, omelette_5.pddl 56 932 11 48 0.495 0.0104259 177 144500 obj_3, omelette_5.pddl 92 2930 46 48 2.709 0.0198585 181 144504 obj_3, omelette_5b.pddl 269 3524 83 49 2.763 0.0517935 409 Definition of an omelette in kitchen_1.pddl # ( :derived ( exist-omelette ?env - env ) ( exists ( ?egg1 - egg ?veggies1 - ingredient ?plate1 - plate ?p - normalcontainer ) ( and ( inside ?plate1 ?egg1 ) ( beaten ?egg1 ) ( fried ?egg1 ) ( folded ?egg1 ) ( is-buttery ?egg1 ) ( fried ?veggies1 ) ( sauteed ?veggies1 ) ( has-seasoning ?egg1 nutmilk cup two ) ( has-seasoning ?egg1 chives tablespoon1 two ) ( seasoning-mixed ?egg1 chives ) ( has-seasoning ?egg1 salt gram two ) ( seasoning-mixed ?egg1 salt ) ( has-seasoning ?egg1 pepper gram two ) ( seasoning-mixed ?egg1 pepper ) ) ) ) Note 2: Objects, Init, and Goals in omelette_5.pddl # (define (problem Omelette) (:domain Kitchen) (:objects ucup1 ucup2 dcup1 dcup2 drawer1 fridge - furniture burner - appliance kitchentop sink - worktop salt pepper chives - seasoning butter - oil nutmilk - liquid veggies1 - ingredient egg1 - egg fork1 - normalutensil spatula1 - cookingutensil tablespoon1 - measureutensil whisk1 - whiskutensil plate1 - plate salter1 shaker1 container1 - normalcontainer milkbottle1 - liquidcontainer smallbowl1 - specialcontainer frypan1 - cookingcontainer robot - agent one two three four - number gram cup - measureunit kitchen - env ) (:init ; ---------------------- ; properties of places that cannot move ; ---------------------- (closed drawer1) (closed dcup1) (closed fridge) (closed dcup2) (closed ucup1) (closed ucup2) (switchedoff burner) ; ---------------------- ; stored in places that cannot move ; ---------------------- (in dcup1 frypan1) (in dcup2 container1) (in fridge egg1) (in fridge veggies1) (in fridge milkbottle1) (in fridge butter) (on kitchentop salter1) (on kitchentop shaker1) (on kitchentop tablespoon1) (on kitchentop fork1) (on kitchentop spatula1) (on kitchentop whisk1) (on kitchentop plate1) (on kitchentop smallbowl1) ; ---------------------- ; stored in movables ; ---------------------- (inside salter1 salt) (inside shaker1 pepper) (inside container1 chives) (inside milkbottle1 nutmilk) ; ---------------------- ; properties of ingredients ; ---------------------- (raw egg1) (sauteed veggies1) (is-butter butter) ) (:goal (and (closed ucup1) (closed ucup2) (closed dcup1) (closed dcup2) (closed drawer1) (closed fridge) (switchedoff burner) (beaten egg1) (fried egg1) (folded egg1) (is-buttery egg1) (fried veggies1) (has-seasoning egg1 salt gram four) (seasoning-mixed egg1 salt) (has-seasoning egg1 pepper gram four) (seasoning-mixed egg1 pepper) (has-seasoning egg1 chives tablespoon1 two) (seasoning-mixed egg1 chives) (has-seasoning egg1 nutmilk cup two) ) ) ) Note 3: the Objects Duplicated in obj_4.pddl and obj_5.pddl # (in dcup1 frypan2) (in dcup2 container2) (in fridge milkbottle2) (on kitchentop salter2) (on kitchentop shaker2) (on kitchentop tablespoon2) (on kitchentop fork2) (on kitchentop spatula2) (on kitchentop whisk2) (on kitchentop plate2) (on kitchentop smallbowl2) (inside salter2 salt) (inside shaker2 pepper) (inside container2 chives) (inside milkbottle2 nutmilk)","title":"Num of Objects"},{"location":"exp-objects/#more-objects-search-time-increases-linearly-with-alternative-utensils","text":"test_objects.sh tests the effect of increasing the number of objects on search complexity by adding objects to obj_0.pddl , with the same set of operators in kitchen_1.pddl and the same goal definition in omelette_5.pddl , i.e. a full omelette: obj_0.pddl contains the bare minimum set of objects --> [Note 2] obj_1.pddl adds 3 extranuous objects (i.e. pot/pan, bread/veggies, oliveoil/butter) obj_2.pddl adds 3 alternative objects (i.e. knife/fork, bigbowl/smallbowl, saltedbutter/butter) obj_3.pddl contains 10 eggs and 10 veggies (the goal mentions egg1 and veggie1) --> [Note 1] obj_4.pddl contains multiples (2) of every utensil (11) --> [Note 3] obj_5.pddl contains multiples (10) of every utensil (11) --> [Conclusion 1] obj_eggs_0.pddl contains the bare minimum set of objects for making 10 egg recipes t problem_name var op axiom plan parse search state ------ -------------- ----- ----- ------- ------ ------- --------- ------- 142459 obj_0.pddl 56 932 11 48 0.483 0.0119011 * 177 142501 obj_1.pddl 61 1522 13 55 1.211 0.0194257 348 142502 obj_2.pddl 60 1280 13 54 0.898 0.0389651 * 580 142505 obj_3.pddl 92 2930 46 48 2.721 0.0209925 181 142507 obj_4.pddl 119 2849 11 63 1.701 0.0684566 * 678 142546 obj_5.pddl 429 56083 11 53 37.081 0.596486 * 907","title":"More objects -&gt; Search time increases linearly with alternative utensils"},{"location":"exp-objects/#conclusion-1-search-time-increases-linearly-with-alternative-utensils","text":"Looking at line 1, line 3 (added 3 alternative utensil), line 5 (duplicated number of utensils by 2), and line 6 (duplicated number of utensils by 10), we notice that search time increases almost linearly number of operators increases more than linearly number of axioms doesn't change plan lengths are different (strange)","title":"Conclusion 1: Search time increases linearly with alternative utensils"},{"location":"exp-objects/#note-1-use-axioms-to-define-recipe","text":"Note that 10 eggs and 10 veggies only has a small effect when the goal mentions only the existance of egg and veggies, as opposed to mentioning egg1 and veggie1 : obj_0.pddl + omelette_5.pddl ( obj_0.pddl contains the bare minimum set of objects) obj_3.pddl + omelette_5.pddl ( obj_3.pddl contains 10 eggs and 10 veggies) obj_3.pddl + omelette_5b.pddl , which contains goal (exist-omelette kitchen) t problem_name var op axiom plan parse search state ------ ----------------------- ----- ---- ------- ------ ------- --------- ------- 144457 obj_0, omelette_5.pddl 56 932 11 48 0.495 0.0104259 177 144500 obj_3, omelette_5.pddl 92 2930 46 48 2.709 0.0198585 181 144504 obj_3, omelette_5b.pddl 269 3524 83 49 2.763 0.0517935 409","title":"Note 1: Use Axioms to define recipe"},{"location":"exp-objects/#definition-of-an-omelette-in-kitchen_1pddl","text":"( :derived ( exist-omelette ?env - env ) ( exists ( ?egg1 - egg ?veggies1 - ingredient ?plate1 - plate ?p - normalcontainer ) ( and ( inside ?plate1 ?egg1 ) ( beaten ?egg1 ) ( fried ?egg1 ) ( folded ?egg1 ) ( is-buttery ?egg1 ) ( fried ?veggies1 ) ( sauteed ?veggies1 ) ( has-seasoning ?egg1 nutmilk cup two ) ( has-seasoning ?egg1 chives tablespoon1 two ) ( seasoning-mixed ?egg1 chives ) ( has-seasoning ?egg1 salt gram two ) ( seasoning-mixed ?egg1 salt ) ( has-seasoning ?egg1 pepper gram two ) ( seasoning-mixed ?egg1 pepper ) ) ) )","title":"Definition of an omelette in kitchen_1.pddl"},{"location":"exp-objects/#note-2-objects-init-and-goals-in-omelette_5pddl","text":"(define (problem Omelette) (:domain Kitchen) (:objects ucup1 ucup2 dcup1 dcup2 drawer1 fridge - furniture burner - appliance kitchentop sink - worktop salt pepper chives - seasoning butter - oil nutmilk - liquid veggies1 - ingredient egg1 - egg fork1 - normalutensil spatula1 - cookingutensil tablespoon1 - measureutensil whisk1 - whiskutensil plate1 - plate salter1 shaker1 container1 - normalcontainer milkbottle1 - liquidcontainer smallbowl1 - specialcontainer frypan1 - cookingcontainer robot - agent one two three four - number gram cup - measureunit kitchen - env ) (:init ; ---------------------- ; properties of places that cannot move ; ---------------------- (closed drawer1) (closed dcup1) (closed fridge) (closed dcup2) (closed ucup1) (closed ucup2) (switchedoff burner) ; ---------------------- ; stored in places that cannot move ; ---------------------- (in dcup1 frypan1) (in dcup2 container1) (in fridge egg1) (in fridge veggies1) (in fridge milkbottle1) (in fridge butter) (on kitchentop salter1) (on kitchentop shaker1) (on kitchentop tablespoon1) (on kitchentop fork1) (on kitchentop spatula1) (on kitchentop whisk1) (on kitchentop plate1) (on kitchentop smallbowl1) ; ---------------------- ; stored in movables ; ---------------------- (inside salter1 salt) (inside shaker1 pepper) (inside container1 chives) (inside milkbottle1 nutmilk) ; ---------------------- ; properties of ingredients ; ---------------------- (raw egg1) (sauteed veggies1) (is-butter butter) ) (:goal (and (closed ucup1) (closed ucup2) (closed dcup1) (closed dcup2) (closed drawer1) (closed fridge) (switchedoff burner) (beaten egg1) (fried egg1) (folded egg1) (is-buttery egg1) (fried veggies1) (has-seasoning egg1 salt gram four) (seasoning-mixed egg1 salt) (has-seasoning egg1 pepper gram four) (seasoning-mixed egg1 pepper) (has-seasoning egg1 chives tablespoon1 two) (seasoning-mixed egg1 chives) (has-seasoning egg1 nutmilk cup two) ) ) )","title":"Note 2: Objects, Init, and Goals in omelette_5.pddl"},{"location":"exp-objects/#note-3-the-objects-duplicated-in-obj_4pddl-and-obj_5pddl","text":"(in dcup1 frypan2) (in dcup2 container2) (in fridge milkbottle2) (on kitchentop salter2) (on kitchentop shaker2) (on kitchentop tablespoon2) (on kitchentop fork2) (on kitchentop spatula2) (on kitchentop whisk2) (on kitchentop plate2) (on kitchentop smallbowl2) (inside salter2 salt) (inside shaker2 pepper) (inside container2 chives) (inside milkbottle2 nutmilk)","title":"Note 3: the Objects Duplicated in obj_4.pddl and obj_5.pddl"},{"location":"exp-operators/","text":"More operators -> Search time increases linearly # test_operators tests the effect of increasing the number of operators (for multiple recipes) on search complexity, with the same omelette.pddl and obj_1.pddl , i.e. minimum plan length & objects: kitchen_1.pddl contains all operators for omelette recipe kitchen_2.pddl contains all operators for omelette + maintanance goals kitchen_3.pddl contains all operators & definitions for 10 egg recipes kitchen_4.pddl contains all operators & definitions for 10 egg recipes, with different action costs that reflect time costs kitchen_5.pddl contains all operators & definitions for egg & baking recipes, with different action costs that reflect time costs t problem_name var op axiom plan parse search state ------ --------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 090721 kitchen_1-omelette_5-obj_1.pddl-omelette_5.pddl 66 1004 11 48 0.659 0.0181792 243 090722 kitchen_2-omelette-obj_1.pddl-omelette.pddl 70 1004 27 64 0.61 0.0349843 519 090733 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.058 0.115542 711 TODO: change the obj_1.pddl here to obj_4 .pddl and obj_eggs.pddl to make the problem combinatorially complicated","title":"Num of Operators"},{"location":"exp-operators/#more-operators-search-time-increases-linearly","text":"test_operators tests the effect of increasing the number of operators (for multiple recipes) on search complexity, with the same omelette.pddl and obj_1.pddl , i.e. minimum plan length & objects: kitchen_1.pddl contains all operators for omelette recipe kitchen_2.pddl contains all operators for omelette + maintanance goals kitchen_3.pddl contains all operators & definitions for 10 egg recipes kitchen_4.pddl contains all operators & definitions for 10 egg recipes, with different action costs that reflect time costs kitchen_5.pddl contains all operators & definitions for egg & baking recipes, with different action costs that reflect time costs t problem_name var op axiom plan parse search state ------ --------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 090721 kitchen_1-omelette_5-obj_1.pddl-omelette_5.pddl 66 1004 11 48 0.659 0.0181792 243 090722 kitchen_2-omelette-obj_1.pddl-omelette.pddl 70 1004 27 64 0.61 0.0349843 519 090733 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.058 0.115542 711 TODO: change the obj_1.pddl here to obj_4 .pddl and obj_eggs.pddl to make the problem combinatorially complicated","title":"More operators -&gt; Search time increases linearly"},{"location":"experiments/","text":"Experiments & Results on Search Complexity # 1. More goal predicates -> Search time increases more than linearly # test_goals.sh tests the effect of increasing the number of goal predicates on search complexity, with the same kitchen_1 .pddl and obj_1 .pddl, i.e. minimum operators & objects: * omelette_1.pddl has only eggs * omelette_2.pddl adds veggies * omelette_3.pddl adds salt and pepper * omelette_4.pddl adds nutmilk and chives * omelette_5.pddl contains all positive goal predicates without any use of axioms * omelette_6.pddl contains one negative goal predicate * omelette_6.pddl contains two negative goal predicates t problem_name var op axiom plan parse search state ------ --------------- ----- ---- ------- ------ ------- ---------- ------- 085529 omelette_1.pddl 39 700 8 16 0.632 0.0016525 29 085530 omelette_2.pddl 43 702 11 20 0.618 0.00334604 40 085531 omelette_3.pddl 44 703 11 24 0.666 0.00299829 48 085532 omelette_4.pddl 58 843 11 50 0.675 0.0119693 246 085533 omelette_5.pddl 66 1004 11 48 0.598 0.0155517 243 085534 omelette_6.pddl 68 1004 13 64 0.579 0.0691776 1134 085535 omelette_7.pddl 68 1004 13 64 0.592 0.0721683 1134 2. More objects -> Search time increases linearly # test_objects.sh tests the effect of increasing the number of objects on search complexity, with the same kitchen_1.pddl and omelette_5.pddl , i.e. full omelette: * obj_1.pddl contains the bare minimum set of objects * obj_2.pddl contains some alternative objects * obj_3.pddl contains 12 eggs * obj_4.pddl contains multiples (two) of every object * obj_5.pddl contains multiples (ten) of every object * obj_eggs.pddl contains all objects for making 10 egg recipes t problem_name var op axiom plan parse search state ------ -------------- ----- ---- ------- ------ ------- --------- ------- 085837 obj_1.pddl 66 1004 11 48 0.61 0.0164124 243 085839 obj_2.pddl 72 1626 14 53 1.448 0.0181531 215 085843 obj_3.pddl 102 3086 44 53 3.889 0.0320748 215 085855 obj_4.pddl 116 9510 46 50 11.723 0.0407923 219 085909 obj_eggs.pddl 115 5416 102 50 13.549 0.031977 219 3. Different recipes -> Search time corresponds to # of axioms and depth of search, instead of # of operators or length of plan # test_egg_recipes.sh tests the search complexity of 10 different egg-related recipes, with the same kitchen_3.pddl and obj_eggs.pddl , i.e. with all definitions and objects for egg recipes: * scrambled_eggs.pddl specifies beaten, scrambled eggs * omelette.pddl specifies beaten, folded eggs with veggies * sunny_side_up.pddl specifies fried, steamed eggs on frypan * egg_in_hole.pddl specifies fried egg in the hole of a bread * poached_egg.pddl specifies boiled egg with vinegar t problem_name var op axiom plan parse search state ------ --------------------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 085358 kitchen_egg_4-scrambled_eggs-obj_egg_4.pddl-scrambled_eggs.pddl 312 6677 161 43 9.846 0.120834 749 085408 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.03 0.119653 711 085419 kitchen_egg_4-sunny_side_up-obj_egg_4.pddl-sunny_side_up.pddl 142 4560 125 28 10.377 0.272117 2501 085432 kitchen_egg_4-egg_in_hole-obj_egg_4.pddl-crack 202 3234 172 50 10.129 2.14165 24498 085447 kitchen_3-poached_egg-obj_eggs.pddl-poached_egg.pddl 368 4944 137 25 14.394 0.0189829 144 4. More operators -> Search time increases linearly # test_operators tests the effect of increasing the number of operators (for multiple recipes) on search complexity, with the same omelette.pddl and obj_1.pddl , i.e. minimum plan length & objects: * kitchen_1.pddl contains all operators for omelette recipe * kitchen_2.pddl contains all operators for omelette + maintanance goals * kitchen_3.pddl contains all operators & definitions for 10 egg recipes * kitchen_4.pddl contains all operators & definitions for 10 egg recipes, with different action costs that reflect time costs * kitchen_5.pddl contains all operators & definitions for egg & baking recipes, with different action costs that reflect time costs t problem_name var op axiom plan parse search state ------ --------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 090721 kitchen_1-omelette_5-obj_1.pddl-omelette_5.pddl 66 1004 11 48 0.659 0.0181792 243 090722 kitchen_2-omelette-obj_1.pddl-omelette.pddl 70 1004 27 64 0.61 0.0349843 519 090733 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.058 0.115542 711 TODO: change the obj_1.pddl here to obj_4 .pddl and obj_eggs.pddl to make the problem combinatorially complicated","title":"Experiments & Results on Search Complexity"},{"location":"experiments/#experiments-results-on-search-complexity","text":"","title":"Experiments &amp; Results on Search Complexity"},{"location":"experiments/#1-more-goal-predicates-search-time-increases-more-than-linearly","text":"test_goals.sh tests the effect of increasing the number of goal predicates on search complexity, with the same kitchen_1 .pddl and obj_1 .pddl, i.e. minimum operators & objects: * omelette_1.pddl has only eggs * omelette_2.pddl adds veggies * omelette_3.pddl adds salt and pepper * omelette_4.pddl adds nutmilk and chives * omelette_5.pddl contains all positive goal predicates without any use of axioms * omelette_6.pddl contains one negative goal predicate * omelette_6.pddl contains two negative goal predicates t problem_name var op axiom plan parse search state ------ --------------- ----- ---- ------- ------ ------- ---------- ------- 085529 omelette_1.pddl 39 700 8 16 0.632 0.0016525 29 085530 omelette_2.pddl 43 702 11 20 0.618 0.00334604 40 085531 omelette_3.pddl 44 703 11 24 0.666 0.00299829 48 085532 omelette_4.pddl 58 843 11 50 0.675 0.0119693 246 085533 omelette_5.pddl 66 1004 11 48 0.598 0.0155517 243 085534 omelette_6.pddl 68 1004 13 64 0.579 0.0691776 1134 085535 omelette_7.pddl 68 1004 13 64 0.592 0.0721683 1134","title":"1. More goal predicates -&gt; Search time increases more than linearly"},{"location":"experiments/#2-more-objects-search-time-increases-linearly","text":"test_objects.sh tests the effect of increasing the number of objects on search complexity, with the same kitchen_1.pddl and omelette_5.pddl , i.e. full omelette: * obj_1.pddl contains the bare minimum set of objects * obj_2.pddl contains some alternative objects * obj_3.pddl contains 12 eggs * obj_4.pddl contains multiples (two) of every object * obj_5.pddl contains multiples (ten) of every object * obj_eggs.pddl contains all objects for making 10 egg recipes t problem_name var op axiom plan parse search state ------ -------------- ----- ---- ------- ------ ------- --------- ------- 085837 obj_1.pddl 66 1004 11 48 0.61 0.0164124 243 085839 obj_2.pddl 72 1626 14 53 1.448 0.0181531 215 085843 obj_3.pddl 102 3086 44 53 3.889 0.0320748 215 085855 obj_4.pddl 116 9510 46 50 11.723 0.0407923 219 085909 obj_eggs.pddl 115 5416 102 50 13.549 0.031977 219","title":"2. More objects -&gt; Search time increases linearly"},{"location":"experiments/#3-different-recipes-search-time-corresponds-to-of-axioms-and-depth-of-search-instead-of-of-operators-or-length-of-plan","text":"test_egg_recipes.sh tests the search complexity of 10 different egg-related recipes, with the same kitchen_3.pddl and obj_eggs.pddl , i.e. with all definitions and objects for egg recipes: * scrambled_eggs.pddl specifies beaten, scrambled eggs * omelette.pddl specifies beaten, folded eggs with veggies * sunny_side_up.pddl specifies fried, steamed eggs on frypan * egg_in_hole.pddl specifies fried egg in the hole of a bread * poached_egg.pddl specifies boiled egg with vinegar t problem_name var op axiom plan parse search state ------ --------------------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 085358 kitchen_egg_4-scrambled_eggs-obj_egg_4.pddl-scrambled_eggs.pddl 312 6677 161 43 9.846 0.120834 749 085408 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.03 0.119653 711 085419 kitchen_egg_4-sunny_side_up-obj_egg_4.pddl-sunny_side_up.pddl 142 4560 125 28 10.377 0.272117 2501 085432 kitchen_egg_4-egg_in_hole-obj_egg_4.pddl-crack 202 3234 172 50 10.129 2.14165 24498 085447 kitchen_3-poached_egg-obj_eggs.pddl-poached_egg.pddl 368 4944 137 25 14.394 0.0189829 144","title":"3. Different recipes -&gt; Search time corresponds to # of axioms and depth of search, instead of # of operators or length of plan"},{"location":"experiments/#4-more-operators-search-time-increases-linearly","text":"test_operators tests the effect of increasing the number of operators (for multiple recipes) on search complexity, with the same omelette.pddl and obj_1.pddl , i.e. minimum plan length & objects: * kitchen_1.pddl contains all operators for omelette recipe * kitchen_2.pddl contains all operators for omelette + maintanance goals * kitchen_3.pddl contains all operators & definitions for 10 egg recipes * kitchen_4.pddl contains all operators & definitions for 10 egg recipes, with different action costs that reflect time costs * kitchen_5.pddl contains all operators & definitions for egg & baking recipes, with different action costs that reflect time costs t problem_name var op axiom plan parse search state ------ --------------------------------------------------- ----- ---- ------- ------ ------- --------- ------- 090721 kitchen_1-omelette_5-obj_1.pddl-omelette_5.pddl 66 1004 11 48 0.659 0.0181792 243 090722 kitchen_2-omelette-obj_1.pddl-omelette.pddl 70 1004 27 64 0.61 0.0349843 519 090733 kitchen_egg_4-omelette-obj_egg_4.pddl-omelette.pddl 350 6680 161 52 10.058 0.115542 711 TODO: change the obj_1.pddl here to obj_4 .pddl and obj_eggs.pddl to make the problem combinatorially complicated","title":"4. More operators -&gt; Search time increases linearly"},{"location":"project-minutes/","text":"Minutes # Link to the editable Google Doc is here . Link to the editable Google Doc is here .","title":"Minutes & Notes"},{"location":"project-minutes/#minutes","text":"Link to the editable Google Doc is here . Link to the editable Google Doc is here .","title":"Minutes"},{"location":"project-plans/","text":"Plans #","title":"Plans & Priorities"},{"location":"project-plans/#plans","text":"","title":"Plans"},{"location":"setup-mkdocs/","text":"Set up the documentation # The documentation source files are in GenesisCore/documentation folder. Here is the layout of the documentation project: mkdocs.yml # The configuration file, e.g., for organizing the pages docs/ index.md # The documentation homepage ... # Other markdown pages imgs/ ... # Images css/ extra.css # style file to customize based on site/theme.css and site/theme_extra.css site/ # You can ignore thing here, MkDocs generNates them when you deploy the page Step 1: Install MkDocs # MkDocs is a Python package for generating static sites, especially good for the documentation style. Documentation source files are written in Markdown, and configured with a single YAML configuration file. You can install MkDocs using pip or other package manager. Install with pip # If you use the Python package manager, pip , then you can: $ pip install --upgrade pip $ pip install mkdocs To check that it is installed: $ mkdocs --version mkdocs, version version 1.2.2 from ... Install with a Package Manager # If you prefer useing another package manager (such as apt-get , dnf , homebrew , yum , chocolatey , etc.) to install packages on your system, then you may install MkDocs with your package manager. Step 2: Start MkDocs Server # MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. Make sure you're in the same directory as the mkdocs.yml configuration file, and then start the server by running the mkdocs serve command: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160402 15:50:43 server:271] Serving on http://127.0.0.1:8000 [I 160402 15:50:43 handlers:58] Start watching changes ... Now you can view the documentation site in http://127.0.0.1:8000/ , being updated in real time as you save your edits to the files. Step 3: Edit Pages # Before you make changes to the documentation, make sure to git pull the latest changes made by others to avoid conflict. Add a page # If you want to add a page to the wiki, reate a new markdown file in the docs/ directory. Then, add its name and markdown file name to mkdocs.yml , where you will see: nav: - Genesis: - Genesis System: index.md - Contribute to Documentation: mkdocs.md - Representation: - Inner Language - Innerese: innerese.md - ... - Fundamentals: - Inference by Rules: inference.md - ... - The current hierarchy and order is designed so that a new student can use the documentation as a tutorial. Major reorganization is possible upon discussion with Yang : Write in Markdown # Our wiki pages are written in Markdown , a lightweight markup language with plain text formatting syntax. The following cheatsheet designed by Theme Spectre showed the most frequently used syntax: To make it even easier to write in Markdown, you can add Markdown plugin to your editor. For example, I use markdown-editor in Atom to enjoy the following features: Toggle text styles using shortcut such as Ctrl+B Continue lists and table rows when press enter Correct ordered list numbers Step 4: Deploy After Editing # NOTE: At this moment, only Yang should deploy the changes to the website to avoid git merge problems. Please let her know of the changes you made. Routine deploy with one command # Currently, the wiki page is hosted publicly on GitHub. We may later shift over to private domains. After you have made the changes, simply do this in the same directory as the mkdocs.yml file: mkdocs gh-deploy --clean The page will be updated on https://ztyang-mit.github.io/tom-minecraft/ . Note that if you only made changes within the documentation folder, you don't have to git push . The deploy command does it for you. Summary # In this article, you have learned how to install the MkDocs package, write documentation pages, and deloy the site. Every time you make changes to the documentation, you need to use the following two commands at the project directory. $ git pull $ mkdocs serve # before editting, start the MkDocs server During editing, you add and organize pages at the configuration page, mkdocs.yml . After editing, you should let Yang know of the changes you made and git push","title":"Set up MkDocs"},{"location":"setup-mkdocs/#set-up-the-documentation","text":"The documentation source files are in GenesisCore/documentation folder. Here is the layout of the documentation project: mkdocs.yml # The configuration file, e.g., for organizing the pages docs/ index.md # The documentation homepage ... # Other markdown pages imgs/ ... # Images css/ extra.css # style file to customize based on site/theme.css and site/theme_extra.css site/ # You can ignore thing here, MkDocs generNates them when you deploy the page","title":"Set up the documentation"},{"location":"setup-mkdocs/#step-1-install-mkdocs","text":"MkDocs is a Python package for generating static sites, especially good for the documentation style. Documentation source files are written in Markdown, and configured with a single YAML configuration file. You can install MkDocs using pip or other package manager.","title":"Step 1: Install MkDocs"},{"location":"setup-mkdocs/#install-with-pip","text":"If you use the Python package manager, pip , then you can: $ pip install --upgrade pip $ pip install mkdocs To check that it is installed: $ mkdocs --version mkdocs, version version 1.2.2 from ...","title":"Install with pip"},{"location":"setup-mkdocs/#install-with-a-package-manager","text":"If you prefer useing another package manager (such as apt-get , dnf , homebrew , yum , chocolatey , etc.) to install packages on your system, then you may install MkDocs with your package manager.","title":"Install with a Package Manager"},{"location":"setup-mkdocs/#step-2-start-mkdocs-server","text":"MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. Make sure you're in the same directory as the mkdocs.yml configuration file, and then start the server by running the mkdocs serve command: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160402 15:50:43 server:271] Serving on http://127.0.0.1:8000 [I 160402 15:50:43 handlers:58] Start watching changes ... Now you can view the documentation site in http://127.0.0.1:8000/ , being updated in real time as you save your edits to the files.","title":"Step 2: Start MkDocs Server"},{"location":"setup-mkdocs/#step-3-edit-pages","text":"Before you make changes to the documentation, make sure to git pull the latest changes made by others to avoid conflict.","title":"Step 3: Edit Pages"},{"location":"setup-mkdocs/#add-a-page","text":"If you want to add a page to the wiki, reate a new markdown file in the docs/ directory. Then, add its name and markdown file name to mkdocs.yml , where you will see: nav: - Genesis: - Genesis System: index.md - Contribute to Documentation: mkdocs.md - Representation: - Inner Language - Innerese: innerese.md - ... - Fundamentals: - Inference by Rules: inference.md - ... - The current hierarchy and order is designed so that a new student can use the documentation as a tutorial. Major reorganization is possible upon discussion with Yang :","title":"Add a page"},{"location":"setup-mkdocs/#write-in-markdown","text":"Our wiki pages are written in Markdown , a lightweight markup language with plain text formatting syntax. The following cheatsheet designed by Theme Spectre showed the most frequently used syntax: To make it even easier to write in Markdown, you can add Markdown plugin to your editor. For example, I use markdown-editor in Atom to enjoy the following features: Toggle text styles using shortcut such as Ctrl+B Continue lists and table rows when press enter Correct ordered list numbers","title":"Write in Markdown"},{"location":"setup-mkdocs/#step-4-deploy-after-editing","text":"NOTE: At this moment, only Yang should deploy the changes to the website to avoid git merge problems. Please let her know of the changes you made.","title":"Step 4: Deploy After Editing"},{"location":"setup-mkdocs/#routine-deploy-with-one-command","text":"Currently, the wiki page is hosted publicly on GitHub. We may later shift over to private domains. After you have made the changes, simply do this in the same directory as the mkdocs.yml file: mkdocs gh-deploy --clean The page will be updated on https://ztyang-mit.github.io/tom-minecraft/ . Note that if you only made changes within the documentation folder, you don't have to git push . The deploy command does it for you.","title":"Routine deploy with one command"},{"location":"setup-mkdocs/#summary","text":"In this article, you have learned how to install the MkDocs package, write documentation pages, and deloy the site. Every time you make changes to the documentation, you need to use the following two commands at the project directory. $ git pull $ mkdocs serve # before editting, start the MkDocs server During editing, you add and organize pages at the configuration page, mkdocs.yml . After editing, you should let Yang know of the changes you made and git push","title":"Summary"},{"location":"setup-repository/","text":"Set up the Repository # To clone the LEAP repository, you need to send Yang your GitHub username to be invited as a collaborator. Open terminal and go to your favorite work directory (e.g., ~/Documents) to clone the project: git clone git@github.com:zt-yang/leap-architecture.git Planners setup # Add FastDownward or PyperPlan as git submodules: git submodule add https://github.com/aibasel/downward.git git submodule add https://github.com/aibasel/pyperplan.git git submodule init git submodule update ./downward/build.py release","title":"Set up the Repository"},{"location":"setup-repository/#set-up-the-repository","text":"To clone the LEAP repository, you need to send Yang your GitHub username to be invited as a collaborator. Open terminal and go to your favorite work directory (e.g., ~/Documents) to clone the project: git clone git@github.com:zt-yang/leap-architecture.git","title":"Set up the Repository"},{"location":"setup-repository/#planners-setup","text":"Add FastDownward or PyperPlan as git submodules: git submodule add https://github.com/aibasel/downward.git git submodule add https://github.com/aibasel/pyperplan.git git submodule init git submodule update ./downward/build.py release","title":"Planners setup"}]}